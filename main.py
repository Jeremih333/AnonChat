import asyncio
import os
from datetime import datetime, timedelta
from aiogram import Bot, F, Dispatcher
from aiogram.filters import Command
from aiogram.types import (
    Message,
    CallbackQuery,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    BotCommand,
)
from aiogram.enums import ChatMemberStatus, ChatType, ParseMode
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application
from aiohttp import web
from database import database
from keyboard import online

if not (token := os.getenv("TELEGRAM_BOT_TOKEN")):
    raise ValueError("TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")

WEBHOOK_URL = os.getenv("WEBHOOK_URL", "https://your-service-name.onrender.com")
PORT = int(os.getenv("PORT", 10000))

bot = Bot(token)
dp = Dispatcher()
db = database("users.db")

DEVELOPER_ID = 1040929628

# Middleware –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
class BlockedUserMiddleware:
    async def __call__(self, handler, event: Message, data):
        user = db.get_user_cursor(event.from_user.id)
        if user:
            now = datetime.now()
            blocked_until = datetime.fromisoformat(user['blocked_until']) if user['blocked_until'] else None
            if user['blocked'] or (blocked_until and blocked_until > now):
                await event.answer("üö´ –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –∏ –Ω–µ –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ—Ç–∞!")
                return
        return await handler(event, data)

dp.message.outer_middleware(BlockedUserMiddleware())

@dp.my_chat_member()
async def handle_block(event: ChatMemberUpdated):
    if event.chat.type == ChatType.PRIVATE:
        user_id = event.from_user.id
        new_status = event.new_chat_member.status
        if new_status == ChatMemberStatus.KICKED:
            db.block_user(user_id, permanent=True)
        elif new_status == ChatMemberStatus.MEMBER:
            db.unblock_user(user_id)

async def check_chats_task():
    while True:
        now = datetime.now()
        long_searches = db.get_users_in_long_search(now - timedelta(minutes=5))
        for user in long_searches:
            db.stop_search(user['id'])
            try:
                await bot.send_message(user['id'], "‚ùå –ü–æ–∏—Å–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–∑-–∑–∞ –¥–æ–ª–≥–æ–≥–æ –æ–∂–∏–¥–∞–Ω–∏—è", reply_markup=online.builder("üîé –ù–∞–π—Ç–∏ —á–∞—Ç"))
            except Exception:
                pass
        
        expired_blocks = db.get_expired_blocks(now)
        for user in expired_blocks:
            db.unblock_user(user['id'])
        
        await asyncio.sleep(180)

@dp.message(Command("unlock"))
async def unlock_user(message: Message):
    if message.from_user.id != DEVELOPER_ID:
        await message.answer("üö´ –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return

    try:
        user_id = int(message.text.split()[1])  # –ü–æ–ª—É—á–∞–µ–º ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –∫–æ–º–∞–Ω–¥—ã
    except (IndexError, ValueError):
        await message.answer("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π Telegram ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏.")
        return

    user = db.get_user_cursor(user_id)
    if not user:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö.")
        return

    if not user['blocked']:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.")
        return

    db.unblock_user(user_id)
    await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID {user_id} —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.")

# –û—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π...

# –ù–∞–ø—Ä–∏–º–µ—Ä, –¥–æ–±–∞–≤—å—Ç–µ –∑–¥–µ—Å—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏

async def on_startup(bot: Bot):
    await bot.set_webhook(f"{WEBHOOK_URL}/webhook")

async def main():
    asyncio.create_task(check_chats_task())

    await bot.set_my_commands([
        BotCommand(command="/start", description="–ù–∞—á–∞—Ç—å –ø–æ–∏—Å–∫"),
        BotCommand(command="/stop", description="–ó–∞–∫–æ–Ω—á–∏—Ç—å –¥–∏–∞–ª–æ–≥"),
        BotCommand(command="/next", description="–ù–æ–≤—ã–π —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫"),
        BotCommand(command="/search", description="–ù–∞—á–∞—Ç—å –ø–æ–∏—Å–∫"),
        BotCommand(command="/link", description="–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –ø—Ä–æ—Ñ–∏–ª–µ–º"),
        BotCommand(command="/interests", description="–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å—ã"),
        BotCommand(command="/dev", description="–ú–µ–Ω—é —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞"),
        BotCommand(command="/unlock", description="–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")  # –ù–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞
    ])

    app = web.Application()
    app["bot"] = bot

    webhook_requests_handler = SimpleRequestHandler(
        dispatcher=dp,
        bot=bot
    )
    webhook_requests_handler.register(app, path="/webhook")

    setup_application(app, dp, bot=bot)
    await on_startup(bot)

    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, host="0.0.0.0", port=PORT)
    await site.start()

    await asyncio.Event().wait()

if __name__ == "__main__":
    asyncio.run(main())
